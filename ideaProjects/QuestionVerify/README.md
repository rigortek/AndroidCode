1 左子树之和 
```

    扩展到右子树之和
    
    其实这个问题的本质还是二叉树的遍历，前、中、后序遍历（尝试优先遍历）以及广度优先遍历
    
    同时实现递归和非递归2种方式
```
2 线段求和
```
   struct Line {
       int start;
       int end;
   };
   输入是一个std::vector数组：[3,5], [4,8], [9,15], [4,10], [16,19], [17,19]
   注意，元素不一定是递增的，要求如果线段区间重合，则合并线段，如果不重合，则将其加入输出vector。

```


3 二分查找
```
2、时间复杂度

比如：总共有n个元素，每次查找的区间大小就是n，n/2，n/4，…，n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数。
由于n/2^k取整后>=1，即令n/2^k=1，
可得k=log2n,（是以2为底，n的对数），所以时间复杂度可以表示O()=O(logn)

```